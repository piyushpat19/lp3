üßÆ Fibonacci Series ‚Äì Time and Space Complexity Analysis
1Ô∏è‚É£ Non-Recursive (Iterative) Fibonacci Program
Program Summary:

This method uses loops to calculate Fibonacci numbers iteratively ‚Äî starting from 0 and 1, then repeatedly adding the two previous numbers.

Algorithm Steps:

Initialize the first two terms: n1 = 0, n2 = 1.

Use a loop to calculate the next term as n3 = n1 + n2.

Update the values:
n1 = n2, n2 = n3.

Repeat until the required term is reached.

Code Example (Python):
def fibonacci_iterative(n):
    n1, n2 = 0, 1
    for i in range(n):
        print(n1, end=" ")
        n1, n2 = n2, n1 + n2

Time Complexity:

O(n)
Because the loop runs once for each term up to n.

Space Complexity:

O(1)
Only a fixed number of variables (n1, n2, n3) are used regardless of n.

2Ô∏è‚É£ Recursive Fibonacci Program
Program Summary:

This method uses recursion ‚Äî each Fibonacci number is computed by calling the function itself for the previous two terms.

Algorithm Steps:

If n <= 1, return n.

Otherwise, return fibo(n-1) + fibo(n-2).

Repeat recursively until base cases are reached.

Code Example (Python):
def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

Time Complexity:

O(2‚Åø)
Each function call generates two more calls (except the base cases), leading to exponential growth.

Example:
fibo(5) ‚Üí calls fibo(4) and fibo(3) ‚Üí each again calls two more functions, and so on.

Space Complexity:

O(n)
Due to the recursion stack, which can go up to n calls deep.

üß© Summary Table
Method	Approach Type	Time Complexity	Space Complexity	Remarks
Non-Recursive	Iterative Loop	O(n)	O(1)	Efficient & simple
Recursive	Function Recursion	O(2‚Åø)	O(n)	Easy to understand but inefficient






















üîπ 1. Fibonacci Sequence Basics

The Fibonacci sequence is:

0, 1, 1, 2, 3, 5, 8, 13, 21, ...


Each term after the first two is the sum of the previous two terms:

ùêπ
(
ùëõ
)
=
ùêπ
(
ùëõ
‚àí
1
)
+
ùêπ
(
ùëõ
‚àí
2
)
F(n)=F(n‚àí1)+F(n‚àí2)

with

ùêπ
(
1
)
=
0
,
ùêπ
(
2
)
=
1
F(1)=0,F(2)=1

So, for example:

F(3) = 1

F(4) = 2

F(5) = 3

F(8) = 13 ‚úÖ (as shown in your output)

üîπ 2. Function: Iterative Approach (Dynamic Programming)
def fibonacci_iterative(n:int):
    if n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        dp = [0] * n
        dp[0] = 0
        dp[1] = 1
        for i in range(2,n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n-1]

üîç Explanation:

This function uses a bottom-up approach.

It builds an array dp[] where each element stores one Fibonacci number.

Step	Action
Line 1-4	Handle base cases n=1 and n=2 directly
Line 5	Create an array dp of size n
Line 6-7	Initialize first two Fibonacci numbers (0,1)
Line 8	Loop from 2 to n-1 to fill remaining values
Line 9	Each new term is sum of previous two (dp[i-1] + dp[i-2])
Line 10	Return dp[n-1], the nth Fibonacci number
‚è±Ô∏è Time Complexity:

O(n) ‚Äî single loop through all numbers.

üíæ Space Complexity:

O(n) ‚Äî stores all Fibonacci numbers in list.

‚úÖ Advantage: Fast and avoids recursive overhead.

üîπ 3. Function: Recursive with Memoization
def fibonacci_recursive(n):
    cache = {
        1:0,
        2:1
    }
    return helper(n,cache)


This initializes a cache (dictionary) with base values and calls a helper function.

üîπ 4. Helper Function: Recursive Computation
def helper(n:int, cache):
    if n in cache:
        return cache[n]
    else:
        return helper(n-1, cache) + helper(n-2, cache)

üîç Explanation:

Checks cache first ‚Äî if the Fibonacci of n was already calculated, just return it.
(This avoids recalculating repeated subproblems.)

Otherwise, recursively compute:

ùêπ
(
ùëõ
)
=
ùêπ
(
ùëõ
‚àí
1
)
+
ùêπ
(
ùëõ
‚àí
2
)
F(n)=F(n‚àí1)+F(n‚àí2)

and store the result in the cache before returning.

üß† Memoization means ‚Äúremembering already solved subproblems.‚Äù

‚è±Ô∏è Time Complexity:

O(n) ‚Äî due to memoization (each Fibonacci number calculated once).

üíæ Space Complexity:

O(n) ‚Äî recursion stack + cache storage.

‚úÖ Advantage: Much faster than plain recursion (which is exponential O(2‚Åø)).

üîπ 5. Taking Input and Printing Output
n = int(input("Enter value of n(nth Fibonacci number): "))
print(f"Fibonacci Number(Iterative): {fibonacci_iterative(n)}")
print(f"Fibonacci Number(Recursive): {fibonacci_recursive(n)}")

üîç Explanation:

Takes user input n.

Calls both functions and prints their results.

Example:

Enter value of n(nth Fibonacci number): 8
Fibonacci Number(Iterative): 13
Fibonacci Number(Recursive): 13


Both methods give the same result ‚úÖ.

üí¨ Short Viva Answers
Question	Answer
What is Fibonacci sequence?	A series where each term is the sum of the previous two terms.
What are F(1) and F(2)?	F(1)=0, F(2)=1
What is Dynamic Programming?	A method that stores intermediate results to avoid repeated work.
What is Memoization?	Storing already computed results in recursion for faster reuse.
What is Time Complexity of iterative version?	O(n)
What is Time Complexity of recursive memoized version?	O(n)
What is difference between recursion and iteration here?	Recursion uses function calls, iteration uses loops and an array.
Why use a cache in recursion?	To prevent recalculating same Fibonacci numbers repeatedly.